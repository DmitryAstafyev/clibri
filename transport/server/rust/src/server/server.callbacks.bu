use super::{
    connection, connection_channel, connection_context, controller, ErrorResponse, Request,
    Response,
};
use connection::Connection;
use connection_context::ConnectionContext;
use controller::Controller;
use log::{debug, error, warn};
use std::collections::HashMap;
use std::net::TcpStream;
use std::sync::mpsc;
use std::sync::mpsc::{Receiver, Sender};
use std::sync::{Arc, RwLock};
use std::thread;
use std::thread::spawn;
use std::{time::Duration};
use tungstenite::accept_hdr;
use tungstenite::protocol::WebSocket;
use uuid::Uuid;
use std::net::TcpListener;

pub enum ServerEvents {
    Connected(Uuid, ConnectionContext),
    Disconnected(Uuid, ConnectionContext),
    Received(Uuid, ConnectionContext, Vec<u8>),
    Error(Option<Uuid>, String),
}

// #[derive(Copy, Clone)]
pub struct Server {
    connections: Arc<RwLock<HashMap<Uuid, Connection>>>,
    error: Option<Arc<RwLock<dyn Fn(Option<Uuid>, String) + Send + Sync + 'static>>>,
    connected: Option<Arc<RwLock<dyn Fn(Uuid, ConnectionContext) + Send + Sync + 'static>>>,
    disconnected: Option<Arc<RwLock<dyn Fn(Uuid, ConnectionContext) + Send + Sync + 'static>>>,
    received: Option<Arc<RwLock<dyn Fn(Uuid, ConnectionContext, Vec<u8>) + Send + Sync + 'static>>>,
    handshake: Option<Arc<RwLock<dyn (Fn(&Request, Response) -> Result<Response, ErrorResponse>) + Send + Sync + 'static>>>,
}

impl<'a> Server where 'a: 'static{
    #[allow(unused_mut)]
    pub fn new() -> Self {
        Server {
            connections: Arc::new(RwLock::new(HashMap::new())),
            handshake: None,
            error: None,
            connected: None,
            disconnected: None,
            received: None
        }
    }

    pub fn handshake<T>(&mut self, handler: T) -> Result<(), String> where T: (Fn(&Request, Response) -> Result<Response, ErrorResponse>) + Send + Sync + 'static {
        if self.handshake.is_some() {
            Err(String::from("Handshake handler is already defined"))
        } else {
            self.handshake = Some(Arc::new(RwLock::new(handler)));
            Ok(())    
        }
    }

    pub fn received<T>(&mut self, handler: T) -> Result<(), String> where T: Fn(Uuid, ConnectionContext, Vec<u8>) + Send + Sync + 'static {
        if self.received.is_some() {
            Err(String::from("connected handler is already defined"))
        } else {
            self.received = Some(Arc::new(RwLock::new(handler)));
            Ok(())    
        }
    }

    pub fn connected<T>(&mut self, handler: T) -> Result<(), String> where T: Fn(Uuid, ConnectionContext) + Send + Sync + 'static {
        if self.connected.is_some() {
            Err(String::from("connected handler is already defined"))
        } else {
            self.connected = Some(Arc::new(RwLock::new(handler)));
            Ok(())    
        }
    }

    pub fn disconnected<T>(&mut self, handler: T) -> Result<(), String> where T: Fn(Uuid, ConnectionContext) + Send + Sync + 'static {
        if self.disconnected.is_some() {
            Err(String::from("disconnected handler is already defined"))
        } else {
            self.disconnected = Some(Arc::new(RwLock::new(handler)));
            Ok(())    
        }
    }

    pub fn error<T>(&mut self, handler: T) -> Result<(), String> where T: Fn(Option<Uuid>, String) + Send + Sync + 'static {
        if self.error.is_some() {
            Err(String::from("error handler is already defined"))
        } else {
            self.error = Some(Arc::new(RwLock::new(handler)));
            Ok(())    
        }
    }

    pub fn listen(&'static mut self, addr: String) -> Result<(), String> {
        let connected_handler = if let Some(handler) = self.connected.clone() {
            handler
        } else {
            return Err(String::from("No connected handler"));
        };
        let error_handler = if let Some(handler) = self.error.clone() {
            handler
        } else {
            return Err(String::from("No error handler"));
        };
        let server: Arc<RwLock<&'static mut Server>> = Arc::new(RwLock::new(self));
        spawn(move || {
            let listener = TcpListener::bind(addr).unwrap();
            for stream in listener.incoming() {
                match stream {
                    Ok(stream) => {
                        match server.write() {
                            Ok(mut server) => {
                                match server.add(stream) {
                                    Ok((uuid, cx)) => {
                                        match connected_handler.write() {
                                            Ok(connected_handler) => connected_handler(uuid, cx.clone()),
                                            Err(e) => error!("Fail get access to received handler due error: {}", e)
                                        }
                                    },
                                    Err(e) => match error_handler.write() {
                                        Ok(error_handler) => error_handler(None, format!("{:?}", e).to_string()),
                                        Err(e) => error!("{}", e)
                                    },
                                }
                            },
                            Err(e) => match error_handler.write() {
                                Ok(error_handler) => error_handler(None, format!("{:?}", e).to_string()),
                                Err(e) => error!("{}", e)
                            },
                        };
                    },
                    Err(e) => match error_handler.write() {
                        Ok(error_handler) => error_handler(None, format!("{:?}", e).to_string()),
                        Err(e) => error!("{}", e)
                    }
                }
            }
        });
        Ok(())
    }

    pub fn add(&mut self, stream: TcpStream) -> Result<(Uuid, ConnectionContext), String> {
        match self.accept(stream) {
            Ok(socket) => {
                let mut conn = connection::Connection::new(socket);
                let mut cx = ConnectionContext {
                    uuid: conn.get_uuid(),
                    connections: self.connections.clone(),
                };
                match self.connections.write() {
                    Ok(mut connections) => {
                        // Register
                        let uuid = conn.get_uuid();
                        let conn = connections.entry(uuid).or_insert(conn);
                        let (tx_channel, rx_channel): (
                            Sender<connection_channel::Messages>,
                            Receiver<connection_channel::Messages>,
                        ) = mpsc::channel();
                        // Listen
                        match conn.listen(tx_channel) {
                            Ok(_) => {
                                self.redirect(rx_channel, cx.clone());
                                Ok((cx.get_uuid(), cx))
                            }
                            Err(e) => {
                                warn!("Client {} error: {}", uuid, e);
                                Err(format!(
                                    "Fail start listening client {} due error: {}",
                                    uuid, e
                                ))
                            }
                        }
                    }
                    Err(e) => {
                        error!("Fail get connections due error: {}", e);
                        Err(format!("Fail get connections due error: {}", e))
                    }
                }
            }
            Err(e) => {
                error!("Fail accept connection due error: {}", e);
                Err(format!("Fail accept connection due error: {}", e))
            }
        }
    }

    fn redirect(&self, rx_channel: Receiver<connection_channel::Messages>, cx: ConnectionContext) {
        let received_handler = if let Some(handler) = self.received.clone() {
            handler
        } else {
            return;
        };
        let error_handler = if let Some(handler) = self.error.clone() {
            handler
        } else {
            return;
        };
        let disconnected_handler = if let Some(handler) = self.disconnected.clone() {
            handler
        } else {
            return;
        };
        spawn(move || {
            let timeout = Duration::from_millis(50);
            loop {
                match rx_channel.try_recv() {
                    Ok(msg) => {
                        match msg {
                            connection_channel::Messages::Binary { uuid, buffer } => {
                                match received_handler.write() {
                                    Ok(received_handler) => received_handler(uuid, cx.clone(), buffer),
                                    Err(e) => error!("Fail get access to received handler due error: {}", e)
                                }
                            }
                            connection_channel::Messages::Error { uuid, error } => {
                                match error_handler.write() {
                                    Ok(error_handler) => error_handler(Some(uuid), format!("{:?}", error).to_string()),
                                    Err(e) => error!("Fail get access to received handler due error: {}", e)
                                }
                            }
                            connection_channel::Messages::Disconnect { uuid, frame: _ } => {
                                match disconnected_handler.write() {
                                    Ok(disconnected_handler) => disconnected_handler(uuid, cx.clone()),
                                    Err(e) => error!("Fail get access to received handler due error: {}", e)
                                }
                            }
                        }
                    }
                    Err(_) => {
                        // No needs logs here;
                        thread::sleep(timeout);
                    }
                }
            }
            // TODO: remove session / connection
        });
    }

    #[allow(unused_mut)]
    fn accept(&mut self, stream: TcpStream) -> Result<WebSocket<TcpStream>, String> {
        let mut handshake_handler = if let Some(h) = self.handshake.clone() {
            h
        } else {
            return Err(String::from("No handler for handshake"))
        };
        match stream.set_nonblocking(true) {
            Ok(_) => {
                debug!("Stream is switched to nonblocking mode");
                match accept_hdr(stream, |req: &Request, mut response: Response| {
                    debug!("Connection is accepted. Calling controller accept-callback");
                    match handshake_handler.write() {
                        Ok(mut handshake_handler) => match handshake_handler(req, response) {
                            Ok(response) => Ok(response),
                            Err(e) => Err(e),
                        },
                        Err(e) => Err(ErrorResponse::new(Some(e.to_string()))),
                    } 
                }) {
                    Ok(socket) => Ok(socket),
                    Err(e) => {
                        warn!(
                            "(accept_hdr) Connection handshake was failed due error: {}",
                            e
                        );
                        Err(e.to_string())
                    }
                }
            }
            Err(e) => {
                warn!("Fail to set stream into nonblocking mode due error: {}", e);
                Err(e.to_string())
            }
        }
    }
}
